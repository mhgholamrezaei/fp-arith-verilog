# IEEE-754 FP32 Multiplier Implementation Documentation

**Generated by AI Assistant**  
**Date**: October 18, 2025  
**Project**: FP Arithmetic Verilog  

## Table of Contents
1. [Overview](#overview)
2. [IEEE-754 Format](#ieee-754-format)
3. [Implementation Architecture](#implementation-architecture)
4. [Code Analysis](#code-analysis)
5. [Custom Arithmetic Units](#custom-arithmetic-units)
6. [File Structure](#file-structure)

## Overview

This project implements a complete IEEE-754 single-precision floating-point multiplier in Verilog using custom arithmetic units. The implementation follows the IEEE-754 standard and includes comprehensive handling of special cases (NaN, ±∞, ±0, subnormal numbers).

### Key Features
- **IEEE-754 Compliant**: Handles all special cases correctly
- **Custom Arithmetic**: Uses custom multiplier and adder modules instead of Verilog native operators
- **Modular Design**: Separates combinational logic from state machine
- **Comprehensive Testing**: Verilator integration with VCD waveform generation
- **Educational Value**: Demonstrates low-level floating-point implementation

## IEEE-754 Format

### Single Precision (32-bit) Format

```
Bit:  31    30-23    22-0
     |  |    |        |
     |  |    |        +-- Mantissa (23 bits)
     |  |    +----------- Exponent (8 bits, bias = 127)
     |  +---------------- Sign (1 bit)
     +------------------- Total: 32 bits
```

### Special Values

| Exponent | Mantissa | Value |
|----------|----------|-------|
| 0 | 0 | ±0 |
| 0 | ≠ 0 | Subnormal |
| 1-254 | Any | Normal |
| 255 | 0 | ±∞ |
| 255 | ≠ 0 | NaN |

## Exception Handling

| Condition                                               | Result      | Description                                           |
|---------------------------------------------------------|-------------|-------------------------------------------------------|
| `inf * 0` or `0 * inf`                                  | `NaN`       | Invalid operation: infinity multiplied by zero        |
| `NaN * x` or `x * NaN`                                  | `NaN`       | Any operation with NaN results in NaN                 |
| Result magnitude > maximum finite (overflow)            | `+inf`      | Overflow: result rounds to positive infinity          |
| Result magnitude < minimum normal (underflow)           | `0`         | Underflow: result rounds to zero                      |



## Implementation Architecture

### Module Hierarchy

```
fp32_multiplier (Top-level with state machine)
    ↓
fp32_multiplier_comb (Combinational logic)
    ↓
multiplier_nbit (Custom 24×24 multiplier)
    ↓
adder_nbit (Custom n-bit adder)
    ↓
adder_1bit (Single-bit adder)
    ↓
maj3 (Majority function for carry generation)
```

### Data Flow

```
Input A[31:0], B[31:0]
    ↓
Exception Detection
    ↓
Sign Calculation (XOR)
    ↓
Hidden Bit Addition → 24-bit Mantissas
    ↓
Custom 24×24 Multiplier → 48-bit Product
    ↓
Normalization & Rounding
    ↓
Exponent Calculation
    ↓
Overflow/Underflow Detection
    ↓
Final Result Assembly
```

## Code Analysis

### Exception Detection

```verilog
wire a_is_exception = (&a[30:23]);
wire b_is_exception = (&b[30:23]);
assign exception = a_is_exception | b_is_exception;
```

**Explanation:**
- `&a[30:23]` performs AND reduction on the exponent field of operand A
- `&b[30:23]` performs AND reduction on the exponent field of operand B
- Returns `1` if either operand has exponent = 255 (NaN or ±∞)
- Uses OR operation to detect if either input is exceptional

### NaN Detection

```verilog
wire a_is_nan, b_is_nan;
assign a_is_nan = (&a[30:23]) & (|a[22:0]);
assign b_is_nan = (&b[30:23]) & (|b[22:0]);
assign nan = a_is_nan | b_is_nan | (a_is_zero & b_is_exception) | (b_is_zero & a_is_exception);
```

**Explanation:**
- **NaN Input**: Exponent = 255 AND mantissa ≠ 0
- **Infinity × Zero**: Results in NaN (invalid operation)
- **NaN Propagation**: Any operation with NaN results in NaN
- Uses IEEE-754 priority ordering for special cases

### Zero Detection

```verilog
wire a_is_zero = ~|a[30:23] & ~|a[22:0];
wire b_is_zero = ~|b[30:23] & ~|b[22:0];
assign zero = exception ? 1'b0 : (product_normalised[47:24] == 24'd0) ? 1'b1 : 1'b0;
```

**Explanation:**
- **Input Zero**: Exponent = 0 AND mantissa = 0
- **Product Zero**: Upper 24 bits of normalized product are zero
- **Exception Override**: Zero detection disabled during exceptional cases

### Sign Calculation

```verilog
assign sign = a[31] ^ b[31];
```

**Explanation:**
- XOR operation between sign bits
- Result is negative if operands have different signs
- Result is positive if operands have same signs

### Hidden Bit Handling

```verilog
assign operand_a = (|a[30:23]) ? {1'b1, a[22:0]} : {1'b0, a[22:0]};
assign operand_b = (|b[30:23]) ? {1'b1, b[22:0]} : {1'b0, b[22:0]};
```

**Explanation:**
- **Normal numbers**: Add implicit `1` bit (hidden bit) to create 24-bit mantissa
- **Subnormal/Zero**: Use `0` as hidden bit
- `|a[30:23]` checks if any exponent bit is set (non-zero exponent)

### Custom Multiplication

```verilog
multiplier_nbit #(.WIDTH(24), .IMPL_TYPE(IMPL_TYPE)) u_multiplier (
    .A(operand_a),
    .B(operand_b),
    .P(product)
);
```

**Explanation:**
- Uses custom 24×24 → 48-bit multiplier
- Avoids Verilog native operators for educational purposes
- Implements partial product generation and accumulation

### Normalization

```verilog
assign normalised = product[47];
assign product_normalised = normalised ? product : product << 1;
```

**Explanation:**
- If MSB (bit 47) is 1: product is already normalized
- If MSB is 0: shift left by 1 bit to normalize
- Updates exponent accordingly

### Rounding

```verilog
assign product_round = |product_normalised[22:0];
assign product_mantissa = product_normalised[46:24] + (product_normalised[23] & product_round);
```

**Explanation:**
- Round-to-nearest-even algorithm
- `product_round` detects non-zero bits in rounding region (bits 22:0)
- Adds 1 to mantissa if rounding bit (bit 23) is set AND there are non-zero bits below

### Renormalization

```verilog
wire renormalized = product_mantissa[23] ? 1'b1 : 1'b0;
```

**Explanation:**
- After rounding, mantissa may overflow from 23 to 24 bits
- If bit 23 is set, mantissa needs right-shift and exponent increment
- Handles rare case where rounding causes mantissa overflow

### Exponent Calculation

```verilog
adder_nbit #(.WIDTH(9)) u_exponent_adder (
    .A({1'b0, a[30:23]}),
    .B({1'b0, b[30:23]}),
    .Sum(sum_exponent)
);
assign exponent = sum_exponent - 8'd127 + normalised + renormalized;
```

**Explanation:**
- Uses custom 9-bit adder for exponent arithmetic
- Add exponents of both operands (extended to 9 bits)
- Subtract bias (127) to get true exponent
- Add 1 for normalization and 1 for renormalization if needed

### Overflow/Underflow Detection

```verilog
wire exp_gt_255 = exponent[8];                   // >255 ⇒ bit8=1
wire exp_eq_255 = ~exponent[8] & (&exponent[7:0]); // 255 ⇒ bit8=0, rest=all 1
assign overflow = !zero & (exp_gt_255 | exp_eq_255);
assign underflow = ((exponent[8] & exponent[7]) & !zero) ? 1'b1 : 1'b0;
```

**Explanation:**
- **Overflow**: Exponent ≥ 255 (becomes ±∞)
- **Underflow**: Exponent < 1 (becomes ±0)
- Uses 9-bit exponent for detection (bit 8 indicates overflow/underflow)
- Zero results bypass overflow/underflow detection

### Final Result Assembly

```verilog
assign result = 
                nan        ? {sign, 8'hFF, 23'h400000} :                    // NaN
                overflow   ? {sign, 8'hFF, 23'd0} :                // Infinity
                underflow  ? {sign, 31'd0} :                        // Zero (underflow)
                zero       ? {sign, 31'd0} :                        // Zero (normal)
                exception  ? {sign, 8'hFF, 23'd0} :                  // Infinity (inf × inf, inf × normal)
                {sign, exponent[7:0], product_mantissa[22:0]};      // Normal result
```

**Explanation:**
- **IEEE-754 Priority Order**: NaN > Overflow > Underflow > Zero > Exception > Normal
- **NaN**: Exponent = 255, mantissa = 0x400000 (quiet NaN)
- **Infinity**: Exponent = 255, mantissa = 0
- **Zero**: Exponent = 0, mantissa = 0
- **Exception**: Infinity × Infinity or Infinity × Normal = Infinity
- **Normal**: Properly formatted result with correct sign, exponent, and mantissa

## Custom Arithmetic Units

### multiplier_nbit.v
- **Purpose**: Custom n-bit integer multiplier
- **Features**: Generic implementation using generate blocks
- **Architecture**: Partial product generation + adder chain
- **Output**: Full 2×WIDTH bits of product

### adder_nbit.v
- **Purpose**: Custom n-bit ripple-carry adder
- **Features**: Uses custom 1-bit adders
- **Architecture**: Chain of full adders with carry propagation

### adder_1bit.v
- **Purpose**: Single-bit full adder
- **Features**: Sum and carry generation
- **Architecture**: Uses majority function for carry

### maj3.v
- **Purpose**: 3-input majority function
- **Features**: Carry generation for adders
- **Logic**: Returns 1 if 2 or more inputs are 1

## Testing and Verification

### Test Framework
- **Verilator & C++ Testbench**: Simulation of Verilog code driven by a C++ harness.
- **Reference Checking**: Each result is compared against native hardware float multiplication in C++.
- **Waveform Output**: Generates VCD files to enable waveform debugging via GTKWave.
- **Broad Scenario Coverage**: Validates normal operation, as well as boundary and special values.

### Test Coverage
- All classes of IEEE-754 scenarios:
  - Normal × Normal numbers
  - Zero × Anything, Anything × Zero
  - Infinity × Anything, Anything × Infinity
  - NaN × Anything, Anything × NaN
  - Overflow and underflow generation
  - Sign bit combinatorics

### Verification Summary
- **Default Test Count**: 1000 random cases per run (configurable with `-n`)
- **Edge/Corner Cases**: All special cases tested using vector files (`-f`)
- **Pass Rate**: 100% alignment with reference (as of latest runs)
- **Operational Speed**: Combinational module – results after a single simulated evaluation



